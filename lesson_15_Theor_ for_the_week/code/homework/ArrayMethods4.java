package homework;
// Создать массив из 20-ти случайных целых чисел из интервала от -100 до 100.
// Выполните сортировку полученного массива.
// Попало ли число 0 в этот массив? (выяснить с помощью binary search)
// Если да, то на какое место (индекс) в массиве?
// Если нет, то на какой индекс его следует поставить?

public class ArrayMethods4 {

    public static void randomNumber(int[] arr, int a, int b) { // метод - поиск случайных целых чисел
        for (int i = 0; i < arr.length; i++) { // перебираем цикл
            arr[i] = (int) (Math.random() * (b - a + 1) + a); // генерируем случайные целые числа от а до b
        }
    }

    public static void printNumber(int[] arr) { // метод - печатает масив целыхчисел
        for (int i = 0; i < arr.length; i++) { // запускаем цикл
            System.out.print(arr[i] + "  "); // печатаем в консоли
        }
        System.out.println(); // печатем пустую строку, как разделитель
    }

    public static void split() { // метод - для оформления кода, разделяем результаты
        System.out.println("_______________________________________________________________________________________"); // печатаем в консолии
    }

    public static void bubbleSort(int[] arr) { // метод - пузырьковая сортировка
        for (int i = 0; i < arr.length - 1; i++) { // перебираем цикл от первого элемента и доконца
            for (int j = 0; j < arr.length - 1 - i; j++) { // правый конец будет двигаться на встречу левому, каждый раз сравнивая на один элемент меньше
                if (arr[j] > arr[j + 1]) { // если число элемента с индеком j больше элемента с индексом j + 1, меняем местами
                    int tmp = arr[j];// объяляем переменную, куда отпраляем  больший элементе с индексом j
                    arr[j] = arr[j + 1]; // на место большего элемента ставим меньший элемент
                    arr[j + 1] = tmp; // на место меньшего элемента ставим больший элемент
                }
            }
        }
    }

    public static int binarySearch(int[] arr, int num) { // метод бинарного поиска для поиска элементов в отсортированом массиве
        int left = 0; // начало массива, равен 0
        int right = arr.length - 1; // конец массива, равен  arr.length - 1

        while (left <= right) { // запускаем цикл, продолжаем поиск пока left не привысит right (сокращаем диапозон поиска)
            int mid = (left + right) / 2; // вычесляем индекс средней точки массива
            if (arr[mid] == num) { // если условие выполняеться, это значит мы нашли искомый элемент
                return mid; // возвращаем индекс этого элемента
            } else if (num < arr[mid]) { // если элемент меньше средней точки масива
                right = mid - 1; // элемент находиться в левой части, обноляем right , что бы сузить диапозон
            } else { // если элемент больше средней точки масива
                left = mid + 1; // элемент находиться в правой части, обноляем left , что бы сузить диапозон
            }
        }
        return -left - 1; // если left становится больше, чем right, это означает, что элемент не найлен в массиве, мы возращаем индекс, на котором элемент мог бы стоять не нарушая сортировку предерживаясь правого края
    }

    public static int binarySearch2(int[] arr, int num) { // метод бинарного поиска для поиска элементов в отсортированом массиве
        int left = 0; // начало массива, равен 0
        int right = arr.length - 1; // конец массива, равен  arr.length - 1

        while (left <= right) { // запускаем цикл, продолжаем поиск пока left не привысит right (сокращаем диапозон поиска)
            int mid = (left + right) / 2; // вычесляем индекс средней точки массива
            if (arr[mid] == num) { // если условие выполняеться, это значит мы нашли искомый элемент
                return mid; // возвращаем индекс этого элемента
            } else if (num < arr[mid]) { // если элемент меньше средней точки масива
                right = mid - 1; // элемент находиться в левой части, обноляем right , что бы сузить диапозон
            } else { // если элемент больше средней точки масива
                left = mid + 1; // элемент находиться в правой части, обноляем left , что бы сузить диапозон
            }
        }
        return right + 1; // если left становится больше, чем right, это означает, что элемент не найлен в массиве, мы возращаем индекс, на котором элемент мог бы стоять не нарушая сортировку предерживаясь левого края
    }

    /* public static int binarySearch3(int[] arr, int num) { // метод бинарного поиска для поиска элементов в отсортированом массиве
        int left = 0; // начало массива, равен 0
        int right = arr.length - 1; // конец массива, равен  arr.length - 1

        while (left <= right) { // запускаем цикл, продолжаем поиск пока left не привысит right (сокращаем диапозон поиска)
            int mid = (left + right) / 2; // вычесляем индекс средней точки массива
            if (arr[mid] == num) { // если условие выполняеться, это значит мы нашли искомый элемент
                return mid; // возвращаем индекс этого элемента
            } else if (num < arr[mid]) { // если элемент меньше средней точки масива
                right = mid - 1; // элемент находиться в левой части, обноляем right , что бы сузить диапозон
            } else { // если элемент больше средней точки масива
                left = mid + 1; // элемент находиться в правой части, обноляем left , что бы сузить диапозон
            }
        }
        return mid; // выдает ошибку, должен возвращать индекс элемента, если он найден в массиве, иначе он будет возвращать индекс середины интервала, где поиск был завершен безуспешно.
    } */

    public static int[] getPositiveNumbers(int[] arr) { // метод для получения массива сположительными числами
        int count = 0; // переменная которая будет принимать положительные числа
        for (int i = 0; i < arr.length; i++) { // перебираем массив
            if (arr[i] > 0) { // проверяем условие, элемент больше 0 - положительный
                count++; // если условие выполняеться плюсуем положительные числа
            }
        }
        int[] positiveArray = new int[count]; // создаем новый массив положительных чисел
        int index = 0; // переменная, которая будут принимать индексы положительных чисел
        for (int i = 0; i < arr.length; i++) { // перебираем цикл
            if (arr[i] > 0) { // проверяем условие, элемент больше 0 - положительный
                positiveArray[index] = arr[i];
                index++;
            }

        }
        return positiveArray; // возвращаем масси положительных чисел
    }

    // Реализовать способ обмена значениями двух переменных целого типа,
    // не используя третьей переменной.
    // В идеале написать метод swap(a, b).

    public static void swap(int[] arr) { // метод, который меняет местами значение двух переменых

        int tmp = arr[0]; // временной переменной t присваиваем значение a
        arr[0] = arr[1]; // значению a присваиваем  значение b
        arr[1] = tmp;     // значению b присваиваем сохраненное значение из t
    }


}

